<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>class *CoderBoundedMatrix*</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-02">
<meta name="DC.source" content="generateDecoderFunction.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>class <b>*CoderBoundedMatrix</b>*</h1>
<!--introduction-->
<p>
<b>CoderBoundedMatrix</b> is a class that represents a matrix with bounded dimensions. The matrix is defined by a <b>DataType</b> and a <b>SizeType</b>. The <b>DataType</b> defines the type of the elements of the matrix, while the <b>SizeType</b> defines the type of the size of the matrix.</p>
<p>The <b>generateDecoderFunction</b> method generates a MATLAB function that decodes the matrix from a byteArray. The information on the size are hardcoded in the function according to the structure returned in the codeInfo.mat object. The output string is appended to the overall decoder function for the specific application.</p>
<pre class="codeoutput error">Error using evalin
Unrecognized function or variable 'generateDecoderFunction'.
</pre>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Functional description</a>
</li>
<li>
<a href="#2">==============================================================================================</a>
</li>
<li>
<a href="#3">function functionScript = generateDecoderFunction(obj, accessName)</a>
</li>
</ul>
</div>
<h2 id="1">Functional description</h2>
<p>A coderBoundedMatrix object is normally characterized by a <tt><a href="name">name</a>_data</tt> variable and a <tt><a href="name">name</a>_size</tt> one. The first thing to do is to typecast the <tt>_size</tt> object in order to understand the dimensions of the matrix as returned by the function.</p>
<p>Once this information has been retrieved, according to the type of data contained in the matrix, different operations are performed.</p>
<p> Primitive matrices In case of primitive matrices, the entire byte array is typecasted to the primitive data type. The resulting vector is then reshaped according to the data_size object and assigned to the output variable. The resulting matrix - when smalled than the specified max size - is padded with zeros.</p>
<p> Non-primitive matrices In this case, the casting is not trivial and is automatically delegated to the Children BaseType associated object. Before doing that, a for-loop is instantiated to iterate over the maximum number of elements in the matrix. We do not loop on the effective size because the matrix should be padded anyway with zeros; however, we check if the index is smaller than the actual size and assign the value to the output matrix, otherwise no action is performed. In order to manage the variable naming, a random string is generated and passed to the children object. The children object will return the name of the variable that has been used to store the result of the decoding. This name is then used to assign the value to the output matrix.</p>
<h2 id="2">==============================================================================================</h2>
<h2 id="3">function functionScript = generateDecoderFunction(obj, accessName)</h2>
<pre class="codeinput">
<span class="keyword">function</span> functionScript = generateDecoderFunction(obj, accessName, nestLevel)

<span class="comment">% Input guard</span>
<span class="keyword">if</span> nargin == 2; nestLevel = 1; <span class="keyword">end</span>

<span class="comment">% Initialize array name and empty function script. % The accessName is given by the parent.</span>
arrayName = strcat(generateRandomString(), <span class="string">'_mat'</span>);
functionScript = {};

<span class="comment">% Get size for reshaping</span>
functionScript = vertcat(functionScript, <span class="keyword">...</span>
    sprintf(<span class="string">"%s_size = reshape(typecast(byteArray(arrayPointer + %i+1:arrayPointer+%i+%i), '%s'), 1, []);"</span>, <span class="keyword">...</span>
    arrayName, <span class="keyword">...</span><span class="comment">                                      % Array name</span>
    obj.DataType.PaddedSize + obj.DataType.Padding, <span class="keyword">...</span><span class="comment"> % Bytearray total size</span>
    obj.DataType.PaddedSize + obj.DataType.Padding, <span class="keyword">...</span><span class="comment"> % Bytearray total size</span>
    obj.SizeType.PaddedSize, <span class="keyword">...</span><span class="comment">                        % Size type size</span>
    obj.SizeType.BaseType.MATLABCastType));             <span class="comment">% Base type size</span>

<span class="comment">%%%% HANDLE MATRIX DECODING</span>
<span class="keyword">if</span> isa(obj.BaseType, <span class="string">"coderPrimitive"</span>)  <span class="comment">% PRIMITIVE TYPES</span>
    <span class="comment">% In this case, we only needƒ to typecast the entire matrix. No need for the size.</span>

    <span class="comment">% Cast byteArray into local array.</span>
    functionScript = vertcat(functionScript, <span class="keyword">...</span>
        sprintf(<span class="string">"%s = cast(typecast(byteArray(arrayPointer+1:arrayPointer+%i*prod(%s_size)), '%s'),'%s');"</span>, <span class="keyword">...</span>
        arrayName, <span class="keyword">...</span><span class="comment">                                  % Array name</span>
        obj.DataType.BaseType.PaddedSize, <span class="keyword">...</span><span class="comment">           % Bytearray effective size</span>
        arrayName, <span class="keyword">...</span><span class="comment">                                  % Array name</span>
        obj.BaseType.MATLABCastType, <span class="keyword">...</span><span class="comment">                % MATLAB type for casting</span>
        obj.BaseType.MATLABType));                      <span class="comment">% Effective, final MATLAB type</span>

    <span class="comment">% Increase arrayPointer;</span>
    <span class="comment">% TODO: Make this a parent method.</span>
    functionScript = vertcat(functionScript, <span class="keyword">...</span>
        sprintf(<span class="string">"arrayPointer = arrayPointer + %i;"</span>, <span class="keyword">...</span>
        obj.PaddedSize));

<span class="keyword">else</span>                                    <span class="comment">% NON-PRIMITIVE TYPES</span>
    <span class="comment">% In this case, we need to loop over the elements of the matrix, and retrieve the decoding from each children object, then parse the result in the corresponding matrix element.</span>

    <span class="comment">% We need to instantiate a for-loop; the index of the loop must be different according to the nesting level.</span>
    indexLoop = repmat(<span class="string">'j'</span>, 1, nestLevel);

    <span class="comment">% We need to loop over only the effective elements</span>
    <span class="comment">% TODO: We could loop over only the effective size</span>
    functionScript = vertcat(functionScript, <span class="keyword">...</span>
        sprintf(<span class="string">"for %s=1:%i %% Variable size"</span>, indexLoop, obj.NumEl));

    <span class="comment">%%%% Generate decoding lines for Base Type.</span>
    <span class="comment">% The increase of the arrayPointer is managed internally, so no need to manage inside the loop.</span>

    <span class="comment">% Generate a random name for the child.</span>
    childAccessName = generateRandomString();
    <span class="comment">% Retrieve decoding function for BaseType.</span>
    outlines = obj.BaseType.generateDecoderFunction(childAccessName,  nestLevel+1);
    <span class="comment">% Append the decoding function to the overall function script.</span>
    functionScript = vertcat(functionScript, outlines);

    <span class="comment">% If the index is smaller than the actual size, assign the value to the output matrix.</span>
    <span class="comment">% FIXME: Check if this works for different byte orders (i.e, row-wise). Otherwise remove if condition.</span>
    functionScript = vertcat(functionScript, <span class="keyword">...</span>
        sprintf(<span class="string">"if %s &lt;= prod(%s_size)"</span>, indexLoop, arrayName), <span class="keyword">...</span>
        sprintf(<span class="string">"%s(%s) = %s;"</span>, arrayName, indexLoop, childAccessName), <span class="keyword">...</span>
        sprintf(<span class="string">"end"</span>));

    <span class="comment">% Close the loop</span>
    functionScript = vertcat(functionScript, sprintf(<span class="string">"end"</span>));

    <span class="comment">% We are out of the loop, so we need to increase the arrayPointer. In particular, we need to skip the size type entirely, because that is not transported in MATLAB.</span>
    functionScript = vertcat(functionScript, <span class="keyword">...</span>
        sprintf(<span class="string">"arrayPointer = arrayPointer + %i; %% Size"</span>, <span class="keyword">...</span>
        obj.SizeType.PaddedSize));

<span class="keyword">end</span>

<span class="comment">%%%% RESHAPE AND ASSIGN</span>
<span class="keyword">if</span> obj.SizeType.Dimension&gt;1
    <span class="comment">% Only the elements up to the effective size should be reshaped; otherwise, we have more elements than the actual size and reshape throws an error.</span>
    <span class="comment">% FIXME: Check if this works for different byte orders (i.e, row-wise).</span>
    functionScript = vertcat(functionScript, <span class="keyword">...</span>
        sprintf(<span class="string">"%s = reshape(%s(1:prod(%s_size)), %s_size);"</span>, <span class="keyword">...</span>
        accessName, arrayName, arrayName, arrayName));
<span class="keyword">else</span>
    <span class="comment">% It's just a vector, we need to make it a row vector.</span>
    functionScript = vertcat(functionScript, <span class="keyword">...</span>
        strcat(sprintf(<span class="string">"%s = reshape(%s, 1, []);"</span>, accessName, arrayName)));
<span class="keyword">end</span>

<span class="comment">% Increase arrayPointer</span>
<span class="comment">% This is needed in case the matrix is padded because i.e. part of a structure.</span>
functionScript = vertcat(functionScript, <span class="keyword">...</span>
    sprintf(<span class="string">"arrayPointer = arrayPointer + %i; %% Padding"</span>, <span class="keyword">...</span>
    obj.Padding));


<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% class **CoderBoundedMatrix**
% *CoderBoundedMatrix* is a class that represents a matrix with bounded dimensions.
% The matrix is defined by a *DataType* and a *SizeType*.
% The *DataType* defines the type of the elements of the matrix, while the *SizeType* defines the type of the size of the matrix.
%
% The *generateDecoderFunction* method generates a MATLAB function that decodes the matrix from a byteArray. The information on the size are hardcoded in the function according to the structure returned in the codeInfo.mat object.
% The output string is appended to the overall decoder function for the specific application.
%
%% Functional description
% A coderBoundedMatrix object is normally characterized by a |<name>_data| variable and a |<name>_size| one. The first thing to do is to typecast the |_size| object in order to understand the dimensions of the matrix as returned by the function.
%
% Once this information has been retrieved, according to the type of data contained in the matrix, different operations are performed.
%
% ** Primitive matrices **
% In case of primitive matrices, the entire byte array is typecasted to the primitive data type. The resulting vector is then reshaped according to the data_size object and assigned to the output variable. The resulting matrix - when smalled than the specified max size - is padded with zeros.
%
% ** Non-primitive matrices **
% In this case, the casting is not trivial and is automatically delegated to the Children BaseType associated object. Before doing that, a for-loop is instantiated to iterate over the maximum number of elements in the matrix. We do not loop on the effective size because the matrix should be padded anyway with zeros; however, we check if the index is smaller than the actual size and assign the value to the output matrix, otherwise no action is performed.
% In order to manage the variable naming, a random string is generated and passed to the children object. The children object will return the name of the variable that has been used to store the result of the decoding. This name is then used to assign the value to the output matrix.
%
%% ==============================================================================================

%% function functionScript = generateDecoderFunction(obj, accessName)
function functionScript = generateDecoderFunction(obj, accessName, nestLevel)

% Input guard
if nargin == 2; nestLevel = 1; end

% Initialize array name and empty function script. % The accessName is given by the parent.
arrayName = strcat(generateRandomString(), '_mat');
functionScript = {};

% Get size for reshaping
functionScript = vertcat(functionScript, ...
    sprintf("%s_size = reshape(typecast(byteArray(arrayPointer + %i+1:arrayPointer+%i+%i), '%s'), 1, []);", ...
    arrayName, ...                                      % Array name
    obj.DataType.PaddedSize + obj.DataType.Padding, ... % Bytearray total size
    obj.DataType.PaddedSize + obj.DataType.Padding, ... % Bytearray total size
    obj.SizeType.PaddedSize, ...                        % Size type size
    obj.SizeType.BaseType.MATLABCastType));             % Base type size

%%%% HANDLE MATRIX DECODING
if isa(obj.BaseType, "coderPrimitive")  % PRIMITIVE TYPES
    % In this case, we only needƒ to typecast the entire matrix. No need for the size.
    
    % Cast byteArray into local array.
    functionScript = vertcat(functionScript, ...
        sprintf("%s = cast(typecast(byteArray(arrayPointer+1:arrayPointer+%i*prod(%s_size)), '%s'),'%s');", ...
        arrayName, ...                                  % Array name
        obj.DataType.BaseType.PaddedSize, ...           % Bytearray effective size
        arrayName, ...                                  % Array name
        obj.BaseType.MATLABCastType, ...                % MATLAB type for casting
        obj.BaseType.MATLABType));                      % Effective, final MATLAB type
    
    % Increase arrayPointer;
    % TODO: Make this a parent method.
    functionScript = vertcat(functionScript, ...
        sprintf("arrayPointer = arrayPointer + %i;", ...
        obj.PaddedSize));
    
else                                    % NON-PRIMITIVE TYPES
    % In this case, we need to loop over the elements of the matrix, and retrieve the decoding from each children object, then parse the result in the corresponding matrix element.
    
    % We need to instantiate a for-loop; the index of the loop must be different according to the nesting level.
    indexLoop = repmat('j', 1, nestLevel);
    
    % We need to loop over only the effective elements
    % TODO: We could loop over only the effective size
    functionScript = vertcat(functionScript, ...
        sprintf("for %s=1:%i %% Variable size", indexLoop, obj.NumEl));
    
    %%%% Generate decoding lines for Base Type.
    % The increase of the arrayPointer is managed internally, so no need to manage inside the loop.
    
    % Generate a random name for the child.
    childAccessName = generateRandomString();
    % Retrieve decoding function for BaseType.
    outlines = obj.BaseType.generateDecoderFunction(childAccessName,  nestLevel+1);
    % Append the decoding function to the overall function script.
    functionScript = vertcat(functionScript, outlines);
    
    % If the index is smaller than the actual size, assign the value to the output matrix.
    % FIXME: Check if this works for different byte orders (i.e, row-wise). Otherwise remove if condition.
    functionScript = vertcat(functionScript, ...
        sprintf("if %s <= prod(%s_size)", indexLoop, arrayName), ...
        sprintf("%s(%s) = %s;", arrayName, indexLoop, childAccessName), ...
        sprintf("end"));
    
    % Close the loop
    functionScript = vertcat(functionScript, sprintf("end"));
    
    % We are out of the loop, so we need to increase the arrayPointer. In particular, we need to skip the size type entirely, because that is not transported in MATLAB.
    functionScript = vertcat(functionScript, ...
        sprintf("arrayPointer = arrayPointer + %i; %% Size", ...
        obj.SizeType.PaddedSize));
    
end

%%%% RESHAPE AND ASSIGN
if obj.SizeType.Dimension>1
    % Only the elements up to the effective size should be reshaped; otherwise, we have more elements than the actual size and reshape throws an error.
    % FIXME: Check if this works for different byte orders (i.e, row-wise).
    functionScript = vertcat(functionScript, ...
        sprintf("%s = reshape(%s(1:prod(%s_size)), %s_size);", ...
        accessName, arrayName, arrayName, arrayName));
else
    % It's just a vector, we need to make it a row vector.
    functionScript = vertcat(functionScript, ...
        strcat(sprintf("%s = reshape(%s, 1, []);", accessName, arrayName)));
end

% Increase arrayPointer
% This is needed in case the matrix is padded because i.e. part of a structure.
functionScript = vertcat(functionScript, ...
    sprintf("arrayPointer = arrayPointer + %i; %% Padding", ...
    obj.Padding));


end
##### SOURCE END #####
-->
</body>
</html>
